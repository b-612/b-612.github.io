{"version":3,"sources":["jquery.mask.js"],"names":["_typeof","obj","Symbol","iterator","constructor","prototype","factory","jQuery","Zepto","define","amd","exports","Meteor","module","require","$","Mask","el","mask","options","p","invalid","getCaret","sel","pos","ctrl","get","dSel","document","selection","cSelStart","selectionStart","navigator","appVersion","indexOf","createRange","moveStart","val","length","text","e","setCaret","is","range","setSelectionRange","createTextRange","collapse","moveEnd","select","events","on","data","keyCode","which","maskDigitPosMapOld","maskDigitPosMap","jMaskGlobals","useInput","behaviour","setTimeout","keydown","keyup","oldValue","trigger","selectOnFocus","target","clearIfNotMatch","regexMask","test","getRegexMask","translation","pattern","optional","recursive","oRecursive","r","maskChunks","i","jMask","charAt","toString","replace","push","digit","join","RegExp","destroyEvents","off","v","method","arguments","calculateCaretPosition","oldVal","newVal","getMasked","caretPosNew","caretPosOld","newValL","oldValL","maskDigitsBeforeCaret","maskDigitsAfterCaret","maskDigitsBeforeCaretAll","maskDigitsBeforeCaretAllOld","caretPos","window","event","inArray","byPassKeys","keyStrokeCompensation","callbacks","skipMaskChars","lastMaskChar","check","lastUntranslatedMaskChar","buf","value","undefined","m","maskLen","valLen","offset","addMethod","resetPos","maskDigitCount","maskDigitPosArr","reverse","maskDigit","valDigit","match","fallback","lastMaskCharDigit","mapMaskdigitPositions","maskDiff","changed","defaultArgs","callback","name","criteria","args","apply","this","remove","caret","placeholder","removeAttr","getCleanVal","getMaskedVal","init","onlyMask","extend","attr","maxlength","maskWatchers","HTMLAttributes","input","prefix","notSameMaskObject","field","maskObject","stringify","JSON","fn","selector","globals","interval","watchInterval","watchInputs","maskFunction","each","clearInterval","setInterval","find","masked","unmask","dataMask","removeData","cleanVal","applyDataMask","maskElements","filter","dataMaskAttr","eventName","isSupported","userAgent","createElement","setAttribute","watchDataMask","0","9","#","A","S"],"mappings":"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","sourcesContent":["/**\n * jquery.mask.js\n * @version: v1.14.16\n * @author: Igor Escobar\n *\n * Created by Igor Escobar on 2012-03-10. Please report any bug at github.com/igorescobar/jQuery-Mask-Plugin\n *\n * Copyright (c) 2012 Igor Escobar http://igorescobar.com\n *\n * The MIT License (http://www.opensource.org/licenses/mit-license.php)\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n/* jshint laxbreak: true */\n/* jshint maxcomplexity:17 */\n/* global define */\n\n// UMD (Universal Module Definition) patterns for JavaScript modules that work everywhere.\n// https://github.com/umdjs/umd/blob/master/templates/jqueryPlugin.js\n(function (factory, jQuery, Zepto) {\n\n    if (typeof define === 'function' && define.amd) {\n        define(['jquery'], factory);\n    } else if (typeof exports === 'object' && typeof Meteor === 'undefined') {\n        module.exports = factory(require('jquery'));\n    } else {\n        factory(jQuery || Zepto);\n    }\n\n}(function ($) {\n    'use strict';\n\n    var Mask = function (el, mask, options) {\n\n        var p = {\n            invalid: [],\n            getCaret: function () {\n                try {\n                    var sel,\n                        pos = 0,\n                        ctrl = el.get(0),\n                        dSel = document.selection,\n                        cSelStart = ctrl.selectionStart;\n\n                    // IE Support\n                    if (dSel && navigator.appVersion.indexOf('MSIE 10') === -1) {\n                        sel = dSel.createRange();\n                        sel.moveStart('character', -p.val().length);\n                        pos = sel.text.length;\n                    }\n                    // Firefox support\n                    else if (cSelStart || cSelStart === '0') {\n                        pos = cSelStart;\n                    }\n\n                    return pos;\n                } catch (e) {}\n            },\n            setCaret: function(pos) {\n                try {\n                    if (el.is(':focus')) {\n                        var range, ctrl = el.get(0);\n\n                        // Firefox, WebKit, etc..\n                        if (ctrl.setSelectionRange) {\n                            ctrl.setSelectionRange(pos, pos);\n                        } else { // IE\n                            range = ctrl.createTextRange();\n                            range.collapse(true);\n                            range.moveEnd('character', pos);\n                            range.moveStart('character', pos);\n                            range.select();\n                        }\n                    }\n                } catch (e) {}\n            },\n            events: function() {\n                el\n                .on('keydown.mask', function(e) {\n                    el.data('mask-keycode', e.keyCode || e.which);\n                    el.data('mask-previus-value', el.val());\n                    el.data('mask-previus-caret-pos', p.getCaret());\n                    p.maskDigitPosMapOld = p.maskDigitPosMap;\n                })\n                .on($.jMaskGlobals.useInput ? 'input.mask' : 'keyup.mask', p.behaviour)\n                .on('paste.mask drop.mask', function() {\n                    setTimeout(function() {\n                        el.keydown().keyup();\n                    }, 100);\n                })\n                .on('change.mask', function(){\n                    el.data('changed', true);\n                })\n                .on('blur.mask', function(){\n                    if (oldValue !== p.val() && !el.data('changed')) {\n                        el.trigger('change');\n                    }\n                    el.data('changed', false);\n                })\n                // it's very important that this callback remains in this position\n                // otherwhise oldValue it's going to work buggy\n                .on('blur.mask', function() {\n                    oldValue = p.val();\n                })\n                // select all text on focus\n                .on('focus.mask', function (e) {\n                    if (options.selectOnFocus === true) {\n                        $(e.target).select();\n                    }\n                })\n                // clear the value if it not complete the mask\n                .on('focusout.mask', function() {\n                    if (options.clearIfNotMatch && !regexMask.test(p.val())) {\n                      p.val('');\n                    }\n                });\n            },\n            getRegexMask: function() {\n                var maskChunks = [], translation, pattern, optional, recursive, oRecursive, r;\n\n                for (var i = 0; i < mask.length; i++) {\n                    translation = jMask.translation[mask.charAt(i)];\n\n                    if (translation) {\n\n                        pattern = translation.pattern.toString().replace(/.{1}$|^.{1}/g, '');\n                        optional = translation.optional;\n                        recursive = translation.recursive;\n\n                        if (recursive) {\n                            maskChunks.push(mask.charAt(i));\n                            oRecursive = {digit: mask.charAt(i), pattern: pattern};\n                        } else {\n                            maskChunks.push(!optional && !recursive ? pattern : (pattern + '?'));\n                        }\n\n                    } else {\n                        maskChunks.push(mask.charAt(i).replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&'));\n                    }\n                }\n\n                r = maskChunks.join('');\n\n                if (oRecursive) {\n                    r = r.replace(new RegExp('(' + oRecursive.digit + '(.*' + oRecursive.digit + ')?)'), '($1)?')\n                      .replace(new RegExp(oRecursive.digit, 'g'), oRecursive.pattern);\n                }\n\n                return new RegExp(r);\n            },\n            destroyEvents: function() {\n                el.off(['input', 'keydown', 'keyup', 'paste', 'drop', 'blur', 'focusout', ''].join('.mask '));\n            },\n            val: function(v) {\n                var isInput = el.is('input'),\n                    method = isInput ? 'val' : 'text',\n                    r;\n\n                if (arguments.length > 0) {\n                    if (el[method]() !== v) {\n                        el[method](v);\n                    }\n                    r = el;\n                } else {\n                    r = el[method]();\n                }\n\n                return r;\n            },\n            calculateCaretPosition: function(oldVal) {\n                var newVal = p.getMasked(),\n                    caretPosNew = p.getCaret();\n                if (oldVal !== newVal) {\n                    var caretPosOld = el.data('mask-previus-caret-pos') || 0,\n                        newValL = newVal.length,\n                        oldValL = oldVal.length,\n                        maskDigitsBeforeCaret = 0,\n                        maskDigitsAfterCaret = 0,\n                        maskDigitsBeforeCaretAll = 0,\n                        maskDigitsBeforeCaretAllOld = 0,\n                        i = 0;\n\n                    for (i = caretPosNew; i < newValL; i++) {\n                        if (!p.maskDigitPosMap[i]) {\n                            break;\n                        }\n                        maskDigitsAfterCaret++;\n                    }\n\n                    for (i = caretPosNew - 1; i >= 0; i--) {\n                        if (!p.maskDigitPosMap[i]) {\n                            break;\n                        }\n                        maskDigitsBeforeCaret++;\n                    }\n\n                    for (i = caretPosNew - 1; i >= 0; i--) {\n                        if (p.maskDigitPosMap[i]) {\n                            maskDigitsBeforeCaretAll++;\n                        }\n                    }\n\n                    for (i = caretPosOld - 1; i >= 0; i--) {\n                        if (p.maskDigitPosMapOld[i]) {\n                            maskDigitsBeforeCaretAllOld++;\n                        }\n                    }\n\n                    // if the cursor is at the end keep it there\n                    if (caretPosNew > oldValL) {\n                      caretPosNew = newValL * 10;\n                    } else if (caretPosOld >= caretPosNew && caretPosOld !== oldValL) {\n                        if (!p.maskDigitPosMapOld[caretPosNew])  {\n                          var caretPos = caretPosNew;\n                          caretPosNew -= maskDigitsBeforeCaretAllOld - maskDigitsBeforeCaretAll;\n                          caretPosNew -= maskDigitsBeforeCaret;\n                          if (p.maskDigitPosMap[caretPosNew])  {\n                            caretPosNew = caretPos;\n                          }\n                        }\n                    }\n                    else if (caretPosNew > caretPosOld) {\n                        caretPosNew += maskDigitsBeforeCaretAll - maskDigitsBeforeCaretAllOld;\n                        caretPosNew += maskDigitsAfterCaret;\n                    }\n                }\n                return caretPosNew;\n            },\n            behaviour: function(e) {\n                e = e || window.event;\n                p.invalid = [];\n\n                var keyCode = el.data('mask-keycode');\n\n                if ($.inArray(keyCode, jMask.byPassKeys) === -1) {\n                    var newVal = p.getMasked(),\n                        caretPos = p.getCaret(),\n                        oldVal = el.data('mask-previus-value') || '';\n\n                    // this is a compensation to devices/browsers that don't compensate\n                    // caret positioning the right way\n                    setTimeout(function() {\n                      p.setCaret(p.calculateCaretPosition(oldVal));\n                    }, $.jMaskGlobals.keyStrokeCompensation);\n\n                    p.val(newVal);\n                    p.setCaret(caretPos);\n                    return p.callbacks(e);\n                }\n            },\n            getMasked: function(skipMaskChars, val) {\n                var buf = [],\n                    value = val === undefined ? p.val() : val + '',\n                    m = 0, maskLen = mask.length,\n                    v = 0, valLen = value.length,\n                    offset = 1, addMethod = 'push',\n                    resetPos = -1,\n                    maskDigitCount = 0,\n                    maskDigitPosArr = [],\n                    lastMaskChar,\n                    check;\n\n                if (options.reverse) {\n                    addMethod = 'unshift';\n                    offset = -1;\n                    lastMaskChar = 0;\n                    m = maskLen - 1;\n                    v = valLen - 1;\n                    check = function () {\n                        return m > -1 && v > -1;\n                    };\n                } else {\n                    lastMaskChar = maskLen - 1;\n                    check = function () {\n                        return m < maskLen && v < valLen;\n                    };\n                }\n\n                var lastUntranslatedMaskChar;\n                while (check()) {\n                    var maskDigit = mask.charAt(m),\n                        valDigit = value.charAt(v),\n                        translation = jMask.translation[maskDigit];\n\n                    if (translation) {\n                        if (valDigit.match(translation.pattern)) {\n                            buf[addMethod](valDigit);\n                            if (translation.recursive) {\n                              if (resetPos === -1) {\n                                  resetPos = m;\n                              } else if (m === lastMaskChar && m !== resetPos) {\n                                  m = resetPos - offset;\n                              }\n\n                              if (lastMaskChar === resetPos) {\n                                  m -= offset;\n                              }\n                            }\n                            m += offset;\n                        } else if (valDigit === lastUntranslatedMaskChar) {\n                            // matched the last untranslated (raw) mask character that we encountered\n                            // likely an insert offset the mask character from the last entry; fall\n                            // through and only increment v\n                            maskDigitCount--;\n                            lastUntranslatedMaskChar = undefined;\n                        } else if (translation.optional) {\n                            m += offset;\n                            v -= offset;\n                        } else if (translation.fallback) {\n                            buf[addMethod](translation.fallback);\n                            m += offset;\n                            v -= offset;\n                        } else {\n                          p.invalid.push({p: v, v: valDigit, e: translation.pattern});\n                        }\n                        v += offset;\n                    } else {\n                        if (!skipMaskChars) {\n                            buf[addMethod](maskDigit);\n                        }\n\n                        if (valDigit === maskDigit) {\n                            maskDigitPosArr.push(v);\n                            v += offset;\n                        } else {\n                            lastUntranslatedMaskChar = maskDigit;\n                            maskDigitPosArr.push(v + maskDigitCount);\n                            maskDigitCount++;\n                        }\n\n                        m += offset;\n                    }\n                }\n\n                var lastMaskCharDigit = mask.charAt(lastMaskChar);\n                if (maskLen === valLen + 1 && !jMask.translation[lastMaskCharDigit]) {\n                    buf.push(lastMaskCharDigit);\n                }\n\n                var newVal = buf.join('');\n                p.mapMaskdigitPositions(newVal, maskDigitPosArr, valLen);\n                return newVal;\n            },\n            mapMaskdigitPositions: function(newVal, maskDigitPosArr, valLen) {\n              var maskDiff = options.reverse ? newVal.length - valLen : 0;\n              p.maskDigitPosMap = {};\n              for (var i = 0; i < maskDigitPosArr.length; i++) {\n                p.maskDigitPosMap[maskDigitPosArr[i] + maskDiff] = 1;\n              }\n            },\n            callbacks: function (e) {\n                var val = p.val(),\n                    changed = val !== oldValue,\n                    defaultArgs = [val, e, el, options],\n                    callback = function(name, criteria, args) {\n                        if (typeof options[name] === 'function' && criteria) {\n                            options[name].apply(this, args);\n                        }\n                    };\n\n                callback('onChange', changed === true, defaultArgs);\n                callback('onKeyPress', changed === true, defaultArgs);\n                callback('onComplete', val.length === mask.length, defaultArgs);\n                callback('onInvalid', p.invalid.length > 0, [val, e, el, p.invalid, options]);\n            }\n        };\n\n        el = $(el);\n        var jMask = this, oldValue = p.val(), regexMask;\n\n        mask = typeof mask === 'function' ? mask(p.val(), undefined, el,  options) : mask;\n\n        // public methods\n        jMask.mask = mask;\n        jMask.options = options;\n        jMask.remove = function() {\n            var caret = p.getCaret();\n            if (jMask.options.placeholder) {\n                el.removeAttr('placeholder');\n            }\n            if (el.data('mask-maxlength')) {\n                el.removeAttr('maxlength');\n            }\n            p.destroyEvents();\n            p.val(jMask.getCleanVal());\n            p.setCaret(caret);\n            return el;\n        };\n\n        // get value without mask\n        jMask.getCleanVal = function() {\n          return p.getMasked(true);\n        };\n\n        // get masked value without the value being in the input or element\n        jMask.getMaskedVal = function(val) {\n          return p.getMasked(false, val);\n        };\n\n        jMask.init = function(onlyMask) {\n            onlyMask = onlyMask || false;\n            options = options || {};\n\n            jMask.clearIfNotMatch  = $.jMaskGlobals.clearIfNotMatch;\n            jMask.byPassKeys       = $.jMaskGlobals.byPassKeys;\n            jMask.translation      = $.extend({}, $.jMaskGlobals.translation, options.translation);\n\n            jMask = $.extend(true, {}, jMask, options);\n\n            regexMask = p.getRegexMask();\n\n            if (onlyMask) {\n                p.events();\n                p.val(p.getMasked());\n            } else {\n                if (options.placeholder) {\n                    el.attr('placeholder' , options.placeholder);\n                }\n\n                // this is necessary, otherwise if the user submit the form\n                // and then press the \"back\" button, the autocomplete will erase\n                // the data. Works fine on IE9+, FF, Opera, Safari.\n                if (el.data('mask')) {\n                  el.attr('autocomplete', 'off');\n                }\n\n                // detect if is necessary let the user type freely.\n                // for is a lot faster than forEach.\n                for (var i = 0, maxlength = true; i < mask.length; i++) {\n                    var translation = jMask.translation[mask.charAt(i)];\n                    if (translation && translation.recursive) {\n                        maxlength = false;\n                        break;\n                    }\n                }\n\n                if (maxlength) {\n                    el.attr('maxlength', mask.length).data('mask-maxlength', true);\n                }\n\n                p.destroyEvents();\n                p.events();\n\n                var caret = p.getCaret();\n                p.val(p.getMasked());\n                p.setCaret(caret);\n            }\n        };\n\n        jMask.init(!el.is('input'));\n    };\n\n    $.maskWatchers = {};\n    var HTMLAttributes = function () {\n        var input = $(this),\n            options = {},\n            prefix = 'data-mask-',\n            mask = input.attr('data-mask');\n\n        if (input.attr(prefix + 'reverse')) {\n            options.reverse = true;\n        }\n\n        if (input.attr(prefix + 'clearifnotmatch')) {\n            options.clearIfNotMatch = true;\n        }\n\n        if (input.attr(prefix + 'selectonfocus') === 'true') {\n          options.selectOnFocus = true;\n        }\n\n        if (notSameMaskObject(input, mask, options)) {\n            return input.data('mask', new Mask(this, mask, options));\n        }\n    },\n    notSameMaskObject = function(field, mask, options) {\n        options = options || {};\n        var maskObject = $(field).data('mask'),\n            stringify = JSON.stringify,\n            value = $(field).val() || $(field).text();\n        try {\n            if (typeof mask === 'function') {\n                mask = mask(value);\n            }\n            return typeof maskObject !== 'object' || stringify(maskObject.options) !== stringify(options) || maskObject.mask !== mask;\n        } catch (e) {}\n    },\n    eventSupported = function(eventName) {\n        var el = document.createElement('div'), isSupported;\n\n        eventName = 'on' + eventName;\n        isSupported = (eventName in el);\n\n        if ( !isSupported ) {\n            el.setAttribute(eventName, 'return;');\n            isSupported = typeof el[eventName] === 'function';\n        }\n        el = null;\n\n        return isSupported;\n    };\n\n    $.fn.mask = function(mask, options) {\n        options = options || {};\n        var selector = this.selector,\n            globals = $.jMaskGlobals,\n            interval = globals.watchInterval,\n            watchInputs = options.watchInputs || globals.watchInputs,\n            maskFunction = function() {\n                if (notSameMaskObject(this, mask, options)) {\n                    return $(this).data('mask', new Mask(this, mask, options));\n                }\n            };\n\n        $(this).each(maskFunction);\n\n        if (selector && selector !== '' && watchInputs) {\n            clearInterval($.maskWatchers[selector]);\n            $.maskWatchers[selector] = setInterval(function(){\n                $(document).find(selector).each(maskFunction);\n            }, interval);\n        }\n        return this;\n    };\n\n    $.fn.masked = function(val) {\n        return this.data('mask').getMaskedVal(val);\n    };\n\n    $.fn.unmask = function() {\n        clearInterval($.maskWatchers[this.selector]);\n        delete $.maskWatchers[this.selector];\n        return this.each(function() {\n            var dataMask = $(this).data('mask');\n            if (dataMask) {\n                dataMask.remove().removeData('mask');\n            }\n        });\n    };\n\n    $.fn.cleanVal = function() {\n        return this.data('mask').getCleanVal();\n    };\n\n    $.applyDataMask = function(selector) {\n        selector = selector || $.jMaskGlobals.maskElements;\n        var $selector = (selector instanceof $) ? selector : $(selector);\n        $selector.filter($.jMaskGlobals.dataMaskAttr).each(HTMLAttributes);\n    };\n\n    var globals = {\n        maskElements: 'input,td,span,div',\n        dataMaskAttr: '*[data-mask]',\n        dataMask: true,\n        watchInterval: 300,\n        watchInputs: true,\n        keyStrokeCompensation: 10,\n        // old versions of chrome dont work great with input event\n        useInput: !/Chrome\\/[2-4][0-9]|SamsungBrowser/.test(window.navigator.userAgent) && eventSupported('input'),\n        watchDataMask: false,\n        byPassKeys: [9, 16, 17, 18, 36, 37, 38, 39, 40, 91],\n        translation: {\n            '0': {pattern: /\\d/},\n            '9': {pattern: /\\d/, optional: true},\n            '#': {pattern: /\\d/, recursive: true},\n            'A': {pattern: /[a-zA-Z0-9]/},\n            'S': {pattern: /[a-zA-Z]/}\n        }\n    };\n\n    $.jMaskGlobals = $.jMaskGlobals || {};\n    globals = $.jMaskGlobals = $.extend(true, {}, globals, $.jMaskGlobals);\n\n    // looking for inputs with data-mask attribute\n    if (globals.dataMask) {\n        $.applyDataMask();\n    }\n\n    setInterval(function() {\n        if ($.jMaskGlobals.watchDataMask) {\n            $.applyDataMask();\n        }\n    }, globals.watchInterval);\n}, window.jQuery, window.Zepto));\n"],"file":"jquery.mask.min.js"}